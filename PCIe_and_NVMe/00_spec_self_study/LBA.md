## 🌈LBA (Logical Block Addressing)

## *LBA가 등장하게 된 이유?*

### ✅ LBA의 배경과 필요성

- 과거에는 초기 하드디스크(HDD)에서는 데이터 저장에 **CHS 방식**을 사용했음

- **CHS 방식**이란 데이터를 Cylinder, Head, Sector로 지정하는 방식

- 이는 실제 물리적 구조를 반영한 주소 체계이지만 여러가지 한계점(제한된 주소 범위, 복잡성, 표준화 어려움 등)이 존재했음

- ***" 해결책 : 논리적 주소 체계 필요하다!! "***

- 이에 저장 장치가 물리적으로 어떻게 생겼는지 OS나 프로그램이 몰라도 되는 방식이 필요했음

- 즉, 단순히 0번 블록부터 1번, 2번...처럼 **일렬 번호처럼 데이터를 지정**하면 좋겠다는 요구가 생겼다.

### ✅ LBA(Logical Block Addressing)의 도입

**1. 개념**

- 디스크를 블록 단위로 나누고, 각 **블록에 번호를 붙여 접근하는 방식** ( *→ 블록 단위 저장 개념* )

- 즉, `LBA 0`, `LBA 1`, `LBA 2` ...와 같은 형식

**2. 장점**

- 단순함 : 물리 구조에 상관없이 블록 번호만 있으면 접근 가능

- 표준화 : 모든 디스크가 동일한 인터페이스를 제공

- 대용량 지원 : 48비트 LBA 지원으로 128PB 이상까지 주소 가능

### ✅ 블록 단위 저장 개념 (블록 vs 바이트)

**1. 바이트 단위 저장 (Byte Addressing)**

- 1바이트 단위로 주소 지정

- 예: 주소 0x1000 → 1바이트 데이터 저장

- RAM에서 흔히 사용되는 방식

**2. 블록 단위 저장 (Block Addressing)**

- 디스크(SSD/HDD)에서는 블록 단위로만 읽고 쓰기 가능

- 보통 한 블록 = 512바이트 또는 4KB

- LBA 하나는 하나의 블록을 가리킴

*"따라서"*

→ 디스크는 바이트 단위로 쓰는 것처럼 보여도 실제로는 항상 블록 단위로 처리됨

→ 예시 : 1바이트만 바꾸더라도 내부적으로는 전체 블록을 읽고 수정한 후 다시 씀 ( 이 때문에 Write Amplification 문제가 발생 )

**3. 예시**

1. LBA 접근

- 사용자가 "파일의 1024번째 바이트"를 요청

- OS는 → 이 바이트가 들어 있는 블록을 계산 (예: LBA 2)

- 디스크는 → **LBA 2 전체 블록(512B or 4KB)** 를 읽어서 해당 바이트 추출

2. SSD에서 쓰기

- 1바이트 수정 요청이 와도 실제로는 전체 블록 읽기 → 수정 → 다시 쓰기

## *LBA의 기본 구조와 단위* 

### ✅ LBA란?

- Logical Block Addressing

- 논리적인 블록 단위의 주소: `LBA 0, 1, 2, 3`... 처럼 순차적인 번호

- 각 LBA는 고정된 크기의 블록을 가리킴 (예: 512 Byte, 4KB 등)

- 즉, 하나의 LBA가 하나의 "논리 블록"을 의미함!

- 내부에서는 **논리 주소(LBA)** 를 **물리 주소(PPN)** 로 변환해서 사용

> *LBA → PPN 매핑은 FTL에서 관리!*

## *NVMe 명령어에서의 SLBA, NLB의 의미와 활용* 

### ✅ SLBA란?

- Starting LBA

- 데이터를 읽거나 쓸 때 시작할 위치 (논리 주소)

- Host가 지정한 Namespace 내의 LBA 공간에서 유효해야 함

- 예를 들어 1TB SSD의 Namespace가 0 ~ 2097151 (4KB 블록 기준)이라고 하면, SLBA는 0 ~ 2097151 중 하나

### ✅ NLB란?

- Number of Logical Blocks

- SLBA부터 몇 개의 블록을 처리할지 지정

- ❗주의 : NLB 값이 n이면 실제로는 n+1개의 블록이 처리됨 ( 0-based counting 이므로! )

### ✅ NVMe 명령 구조 내 SLBA, NLB

| 필드    | 크기 (비트) | 설명                            |
| ----- | ------- | ----------------------------- |
| CDW10 | 32      | SLBA\[31:0]                   |
| CDW11 | 32      | SLBA\[63:32]                  |
| CDW12 | 32      | NLB (0-based) + 기타 control 비트 |

> 즉, **SLBA는 CDW10, CDW11에 걸쳐 64비트로 구성**되고, **NLB는 CDW12에 포함**되어 있음

### ✅ 정상적인 상황에서 "서로 다른 LBA가 같은 물리 구조(PPN)를 가리키는 일은 절대 없어야 한다!!"

- LBA는 논리적으로 "1:1" 매핑 구조를 가져야 한다.

- 즉, FTL은 **하나의 LBA ↔ 하나의 PPN (물리 페이지)** 로 1:1 대응을 만족하도록 해야한다.

- 그렇지 않으면 **데이터 무결성(Data Integrity)** 이 깨지고, 오류 또는 데이터 덮어쓰기 위험이 발생하기 때문이다.

### ✅ NVMe SSD에서는 read/write가 항상 “블록 단위(LBA 단위)”로 수행된다.

- SSD는 바이트 단위 read/write는 할 수 없다.

- *READ : 전체 블록을 읽고, 그 안에서 원하는 바이트를 추출*

- *WRITE : 전체 블록을 읽고, 특정 바이트만 수정한 뒤 전체 블록을 다시 씀*
